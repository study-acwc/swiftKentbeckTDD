# Kent Beck 『테스트 주도 개발』 스터디 기록

## 배운 점

- 테스트와 구현 단계를 더 작은 단위로 나눌 수 있음을 깨달았다.  
- 중복 제거를 목표로 코드를 지속적으로 개선했다.  
- p144까지 진행하면서 *“어떻게 이런 구조가 만들어졌지?”* 하는 신기함을 느꼈다.  

---

## 8장: Dollar / Franc 중복 제거

- 테스트가 하위 클래스에 의존하지 않고 상위 타입에 의존하도록 변경해도 동일하게 성공하도록 만들었다.  
- 이를 통해 **어떤 모델 코드에도 영향을 주지 않고 상속 구조를 자유롭게 변경할 수 있게 되었다.**

---

## 9장: 하위 클래스 제거 준비

- 하위 클래스를 제거하기 위해 두 클래스의 `currency` 구현을 동일하게 리팩터링했다.  
- *“불안하면 보폭을 좁히고, 답답하면 보폭을 넓혀라.”* — TDD 과정 전반에서 지속적으로 적용해야 할 조율임을 배웠다.  
- 중복된 부분을 호출자(팩터리 메서드)로 옮겨 두 생성자를 일치시켰다.  

---

## 10~11장: Money의 하위 클래스 제거

- 하위 클래스에서 상위 클래스로 메서드를 올리기 전에, 먼저 모든 하위 클래스의 코드가 동일해지도록 리팩터링했다.  
- 구조가 바뀌면서 불필요해진 테스트는 리팩터링 과정에서 제거했다.  

---

## 12장: 가짜 구현을 통한 탐색

- 설계 방향이 명확하지 않을 때는 **가짜 구현으로 시작하고, 이후 리팩터링하는 방식**으로 접근했다.  

---

## 13장: 서로 다른 화폐 간 합산 로직 시작

- 큰 테스트를 작은 테스트로 나누어 진행했다.  
  - 예: `$5 + 10CHF` → `$5 + $5`  
- 모든 중복이 제거되기 전까지는 테스트를 완성된 것으로 보지 않았다.  

---

## 14장: 라이브러리 연산 검증

- 라이브러리 연산에 대한 가정을 테스트 코드로 작성해 직접 검증했다.  

---

## 15장: `$5 + 10CHF` 구현

- 테스트 코드의 반환 타입을 상위 타입으로 바꾸고, 발생하는 컴파일 에러를 해결하면서 해당 멤버를 상위 타입으로 옮기는 방식으로 리팩터링했다.  

---

## 16장: Money를 Expression으로 일반화 🔥

- TDD로 구현할 경우 테스트 코드의 줄 수와 모델 코드의 줄 수가 거의 비슷해진다.  
- TDD가 경제적이려면 매일 만들어내는 코드의 양이 두 배가 되거나, 동일한 기능을 절반의 코드로 구현해야 한다.  
- 또한 TDD와 기존 방식의 차이를 측정할 때는 디버깅, 통합, 설명에 걸리는 시간까지 포함해야 한다는 점을 깨달았다.  

### 번역 이슈 (p147~148)

- `$5 + $5` 연산에서 `Money`를 반환하는지 실험하기 위한 테스트 추가  

```java
public void testPlusSameCurrencyReturnsMoney() {
    Expression sum = Money.dollar(1).plus(Money.dollar(1));
    assertTrue(sum instanceof Money);  // Sum이 아닌 Money가 반환되길 기대
}
````

* 책의 번역에서는 이 테스트를 통과시키기 위한 코드 예시가 모호했으나, 실제 의도는 아래와 같았다.

```java
public Expression plus(Expression addend) {
    return new Sum(this, addend);
}
```

* 하지만 인자가 `Money`일 경우, 그 통화가 동일한지 확인하는 분명하고도 깔끔한 방법은 제시되지 않았다.
* 만약 설명대로 구현하면 다음과 같은 코드가 되지만, 이는 깔끔한 방법이라고 보기 어렵다.

```java
public Expression plus(Expression addend) {
    if (addend instanceof Money && this.currency.equals(((Money)addend).currency)) {
        return new Money(this.amount + ((Money)addend).amount, currency);
    }
    return new Sum(this, addend);
}
```
